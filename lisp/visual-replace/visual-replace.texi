\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename visual-replace.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx.@*
@end ifinfo
@settitle Visual Replace
@defindex ge
@paragraphindent 0
@exampleindent 4
@finalout
@dircategory Emacs
@direntry
* visual-replace: (visual-replace.info). A nicer interface for string-replace and query-replace
                        that supports previews.
@end direntry

@c %**end of header

@copying
@quotation
Visual-Replace

Stephane Zermatten

Copyright @copyright{} 2020-2024, Stephane Zermatten
@end quotation

@end copying

@titlepage
@title Visual Replace
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top Visual Replace
@insertcopying
@end ifnottex

@c %**start of body
@anchor{index doc}@anchor{0}
Visual Replace provides a nicer interface to Query-Replace@footnote{https://www.gnu.org/software/emacs/manual/html_node/emacs/Query-Replace.html}
than the built-in one.

The main improvements are:

@quotation


@itemize *

@item 
The prompt of Visual Replace includes both the text to be
replaced and the replacement. This makes it easier to craft
possibly complex regular expression search and replace.

@item 
You can see the matches and how they’re going to be modified
as you edit the command arguments.

@item 
To help craft the search string and its replacement, you
can navigate between matches with the arrow keys and
optionally see the number of matches in the prompt.

@item 
You can apply only some replacements, selectively,
using keyboard shortcuts, or by clicking on the preview.

@item 
You can modify the scope and type of the search-and-replace
command, to the full buffer, the region or everything after
the point.
@end itemize
@end quotation

Visual Replace is just an interface. The actual replacements are
always done by the standard Emacs commands.

@menu
* Comparison with other packages:: 
* Contents:: 
* Index:: 

@end menu

@node Comparison with other packages,Contents,Top,Top
@anchor{index comparison-with-other-packages}@anchor{1}@anchor{index visual-replace}@anchor{2}
@chapter Comparison with other packages


What seems to be unique about Visual Replace is the ability to edit
both the thing to be replaced and the replacement at the same time.
The other packages I’ve found make it a 2-step process.

visual-regexp@footnote{https://github.com/benma/visual-regexp.el} also
supports a preview, but uses its own search-and-replace mechanism and
only supports a regexp mode.

anzu@footnote{https://github.com/emacsorphanage/anzu} is otherwise very
similar to visual-replace. It was abandoned for a long time, but has
been recently taken up by a new maintainer.

@node Contents,Index,Comparison with other packages,Top
@anchor{index contents}@anchor{3}
@chapter Contents


@menu
* Installation:: 
* Usage:: 
* Contributing:: 

@end menu

@node Installation,Usage,,Contents
@anchor{install doc}@anchor{4}@anchor{install installation}@anchor{5}
@section Installation


Install Visual Replace:


@itemize -

@item 
from MELPA or MELPA Stable@footnote{https://melpa.org/#/getting-started} using @code{M-x package-install visual-replace}

@item 
on a recent version of Emacs (29 or later), from the
github repository by doing @code{M-x package-vc-install
https://github.com/szermatt/visual-replace}

@item 
from source, using an alternative package managers, such as straight@footnote{https://github.com/radian-software/straight.el}, shown here:

@example
(use-package visual-replace
  :straight (:type git :repo "https://github.com/szermatt/visual-replace.git"))
@end example

@item 
the old-fashioned way, copying visual-replace.el@footnote{https://raw.githubusercontent.com/szermatt/visual-replace/refs/heads/master/visual-replace.el}
into your @code{.emacs.d} directory.
@end itemize

Visual Replace requires Emacs 26.1 or later.

@node Usage,Contributing,Installation,Contents
@anchor{usage doc}@anchor{6}@anchor{usage usage}@anchor{7}
@section Usage


@menu
* Calling Visual Replace:: 
* Visual Replace Mode:: 
* Yank and Pop:: 
* Single replacements:: 
* Customization:: 
* Commands:: 
* Keymaps:: 
* Hooks:: 
* Limitations:: 

@end menu

@node Calling Visual Replace,Visual Replace Mode,,Usage
@anchor{usage calling-visual-replace}@anchor{8}
@subsection Calling Visual Replace


Visual Replace needs to be bound to a key to be of any use.

Choose a reasonably short key combination and bind
@code{visual-replace} to it. It should be reasonably short, because
@code{visual-replace}, by default, uses the key combination it’s
called with as prefix for the commands available in the minibuffer.

Here’s an example that uses @code{M-%} as key combination, since this
is bound by default to @code{query-replace}, which Visual Replace
then, well, replaces:

@example
(use-package visual-replace
  :defer t
  :bind (("M-%" . visual-replace)
         :map isearch-mode-map
         ("M-%" . visual-replace-from-isearch))
  :config
  (define-key visual-replace-mode-map (kbd "M-%")
              visual-replace-secondary-mode-map))
@end example

The above example also binds @code{M-%} in isearch, so you can just
switch from isearch to Visual Replace. Additionally, while Visual
Replace is active @code{M-%} is the prefix for Visual Replace
commands, so, for example, toggling regexp mode on and off is
@code{M-% r}.

An alternative, which you might prefer to try things out, is to
replace @code{query-replace} and others with Visual Replace. This
then uses whatever shortcut you’ve already installed.

@example
(use-package visual-replace
  :defer nil
  :config
  (visual-replace-global-mode 1))
@end example

Once this is done, launch @code{visual-replace} with the keybinding you chose.

@node Visual Replace Mode,Yank and Pop,Calling Visual Replace,Usage
@anchor{usage visual-replace-mode}@anchor{9}
@subsection Visual Replace Mode


When Visual Replace is running, you’ll see, something like the
following in the minibuffer @cite{Replace from point […]: ┃ →}. The text
before the arrow is the text to replace and the text after the arrow
is the replacement. You can navigate back and forth with @code{TAB} or
by moving the cursor.

See also the example below.

@quotation

@image{visual-replace-figures/cast,,,Screen grab showing Visual Replace in action,gif}
@end quotation

Once both fields are filled, press @code{RET} to execute the
replacement.

When there’s no replacement @code{RET} instead moves the cursor to the
replacement, in case muscle memory kicks in and you type: `text to
replace' @code{RET} `replacement' @code{RET}. That’ll work.

The prompt also displays the mode of replacement:


@itemize *

@item 
`text' → `replacement' executes @cite{string-replace}

@item 
`text' →? `replacement' executes @cite{query-replace}

@item 
`text' →.* `replacement' executes @cite{replace-regexp}

@item 
`text' →?.* `replacement' executes @cite{query-replace-regexp}
@end itemize

After typing a few characters of the string to match @cite{visual-replace}
enters preview mode, and highlights the matches. It also scrolls the
window to keep at least one example of matches visible. You can also
press up and down to go through the matches.

In Visual Replace mode:


@itemize *

@item 
@code{TAB} navigates between the text to replace and the
replacement string

@item 
@code{RET} switches to the replacement string, the first time, then
executes the replacement

@item 
@code{M-% r} toggles regexp mode on and off. You know this mode is
on when a @code{.*} follows the arrow.

@item 
@code{M-% q} toggles query mode one and off, that is, it toggles
between calling @code{replace-string} and @code{query-replace}.
You know this mode is on when a @code{?} follows the arrow. See
also @ref{a,,Single replacements} for an alternative way of replacing only some
matches.

@item 
@code{M-% SPC} switches between different scopes: full buffer, from
point, in region. The scope is indicated in the prompt.
Additionally, for from point and in region, the region is
highlighted.

@item 
@code{M-% w} toggle limiting search to whole words. You know this
mode is on when a @code{w} follows the arrow.

@item 
@code{M-% c} toggle case-fold. You know this mode is on when a
@code{c} follows the arrow.

@item 
@code{M-% s} toggle lax whitespace. You know this mode is on when
@code{(lax ws)} follows the arrow.

@item 
@code{<up>} and @code{<down>} move the cursor to the next or
previous match, scrolling if necessary.

@item 
@code{M-% a} applies a single replacement, to the match right under
the cursor or following the cursor, then move on to the next match.
With a prefix argument N, apply N replacements. See also @ref{a,,Single replacements}.

@item 
@code{M-% u} calls @code{undo} on the original buffer, to revert a
previous replacement. With a prefix argument N, repeat undo N times.

@item 
As usual, @code{C-p} and @cite{C-n} go up and down the history, like on any prompt.
@end itemize

(Reminder: replace `M-%' with the keyboard shortcut you chose.)

If you leave @code{visual-replace} without confirming, with @code{C-g}, you can
continue where you left off next time by going up in the history.

See Search@footnote{https://www.gnu.org/software/emacs/manual/html_node/emacs/Search.html}
in the Emacs manual for details of the different modes listed above.

@node Yank and Pop,Single replacements,Visual Replace Mode,Usage
@anchor{usage yank}@anchor{b}@anchor{usage yank-and-pop}@anchor{c}
@subsection Yank and Pop


@geindex function; visual-replace-yank
@geindex function; visual-replace-yank-pop

Yank, usually bound to @code{C-y}, works differently in Visual Replace
than it does normally. In Visual Replace mode, it calls
@code{visual-replace-yank}.


@itemize *

@item 
In the search section, yanking copies text from the current buffer
into the search section. This avoids typing text when it’s right
under the point.

You can also move to a match with @code{<up>} and @code{<down>} to
capture more text from the buffer.

@item 
In the replacement section, yanking copies text from the search
section. This avoids typing the search string again when you just
want to make some small changes to it.
@end itemize

The normal yank can be executed by calling @code{yank-pop}, usually
bound to @code{M-y}.

This can be configured by editing @cite{visual-mode-map}. For example, to
use the normal yank commands, you can do:

@example
(define-key visual-replace-mode-map [remap yank] nil)
(define-key visual-replace-mode-map [remap yank-pop] nil)
@end example

@node Single replacements,Customization,Yank and Pop,Usage
@anchor{usage single}@anchor{a}@anchor{usage single-replacements}@anchor{d}
@subsection Single replacements


If you want to replace only `some' matches within the scope, you can:


@itemize *

@item 
use the @code{query-replace} UI to go through all matches using
@code{M-% q}, then typing @code{RET} to enter Query Replace mode. `

@item 
in preview mode, click on the replacements you want to apply. You
can scroll the buffer as needed, normally or, from the minibuffer
with @code{<up>} and @code{<down>}.

@item 
navigate to the replacements you want to apply with @code{<up>} and
@code{<down>}, the call @code{M-% a} to apply one replacement.

On Emacs 29.1 or later, this enters a mode that allows applying
replacement with @code{a}, the last part of the key sequence, and
also moving through the matches with @code{<down>} or @code{<up>}.
@code{u} reverts the last replacement.
@end itemize

@node Customization,Commands,Single replacements,Usage
@anchor{usage customization}@anchor{e}@anchor{usage options}@anchor{f}
@subsection Customization


@geindex variable; visual-replace-keep-initial-position
@geindex variable; visual-replace-display-total
@geindex variable; visual-replace-preview
@geindex variable; visual-replace-first-match
@geindex variable; visual-replace-initial-scope
@geindex variable; visual-replace-default-to-full-scope
@geindex variable; visual-replace-defaults-hook
@geindex variable; visual-replace-minibuffer-mode-hook
@geindex variable; visual-replace-min-length

This section lists a few of the most interesting customization options
available in visual replace. Call @code{M-x customize-group
visual-replace} to see all options.

Notably, see that customization group for the available customizable
faces.


@itemize *

@item 
@code{M-x customize-option visual-replace-preview} With this option
enabled, Visual Replace highlights matches and offer a preview of
their replacements. This is enabled by default.

@item 
@code{M-x customize-option visual-replace-first-match} With this
option enabled, Visual Replace always tries to have at least one
match visible in the preview, even if it means jumping to another
section of the buffer. This is enabled by default.

@item 
@code{M-x customize-option keep-initial-position} With this option
enabled, Visual Replace goes back to the point it was called from,
even if the point was moved during preview, to display the first
match, or manually with @code{<down>} or @code{<up>}.

Note that in the case where the point is moved during preview,
Visual Replace sets a mark at the original location, to go back too
if necessary.

@item 
@code{M-x customize-option visual-replace-display-total} By default,
in preview mode, visual Replace only searches for and display
matches in the visible portions of the buffer. With this option
enabled, Visual Replace searches the whole buffer, in an idle timer,
and displays the total number of matches in the prompt.

When the point is on a match, the index of the match is also
displayed, in front of the total.

The total might be slow to update on large buffers or when using
complicated regexps.

This is not enabled by default.

@item 
@code{M-x customize-option visual-replace-initial-scope} With this
option set, the initial scope ignores the active region
entirely and is always set to either “From Point” or “Full Buffer”.

By default, the initial scope is:

@quotation


@itemize *

@item 
the active region, if there is one

@item 
from point if @code{visual-replace-default-to-full-scope} is nil, see below

@item 
the full buffer otherwise
@end itemize
@end quotation

@item 
@code{M-x customize-option visual-replace-default-full-scope} With
this option set, when no region is active, replacement applies by
default to the full buffer, instead of to the region following the
point.

@item 
@code{M-x customize-option visual-replace-defaults-hook} To modify
search and replace defaults, such as, for example, having searches
default to regular expressions or search default to word mode, call
the command that turns it on from this hook. This is called when
Visual Replace is started with no initial text, so these
customizations won’t apply to @code{visual-replace-from-isearch},
for example.

@item 
@code{M-x customize-option visual-replace-minibuffer-mode-hook} This
hook is called when Visual Replace is started in the minibuffer. It
can be used to turn on query mode in all cases by registering the
command @code{visual-replace-toggle-query} in this hook.

Rather than setting the as a customization, with
@code{use-package}, you can force Visual Replace to call
@code{query-replace} by default with:

@example
(use-package visual-replace
  [...]
  :hook ((visual-replace-minibuffer-mode . visual-replace-toggle-query))
@end example

@item 
@code{M-x customize-option visual-replace-min-length} This specifies
the minimum number of characters that need to be typed before Visual
Replace enters preview mode.

Setting this too low might result in strange highlights happening
when starting to type in the match string.
@end itemize

@node Commands,Keymaps,Customization,Usage
@anchor{usage commands}@anchor{10}@anchor{usage id1}@anchor{11}
@subsection Commands


@geindex command; visual-replace
@geindex command; visual-replace-thing-at-point
@geindex command; visual-replace-selected
@geindex command; visual-replace-from-isearch


@itemize *

@item 
@code{visual-replace} is the main command that starts Visual Replace and
then executes the search-and-replace. It can replace @code{replace-string},
@code{query-replace}, @code{replace-regexp} and @code{query-replace-regexp}.

@item 
@code{visual-replace-thing-at-point} starts a visual replace session with
the symbol at point as text to replace.

@item 
@code{visual-replace-selected} starts with the text within the current
active region as text to replace.

@item 
@code{visual-replace-from-isearch} switches from an active isearch
session to @code{visual-replace}, keeping the current search text and
settings, such as regexp mode. This is meant to be called while
isearch is in progress, and bound to @code{isearch-mode-map}.
@end itemize

@geindex command; visual-replace-toggle-regexp
@geindex command; visual-replace-toggle-scope
@geindex command; visual-replace-toggle-query
@geindex command; visual-replace-toggle-word
@geindex command; visual-replace-toggle-case-fold
@geindex command; visual-replace-toggle-lax-ws
@geindex command; visual-replace-next-match
@geindex command; visual-replace-prev-match
@geindex command; visual-replace-apply-one
@geindex command; visual-replace-apply-one-repeat
@geindex command; visual-replace-undo
@geindex variable; visual-replace-transient-map

The following commands are meant to be called while in Visual Replace
mode, from @code{visual-mode-map}. By default, they’re bound in
@code{visual-replace-secondary-mode-map}:


@itemize *

@item 
@code{visual-replace-toggle-regexp} toggles regexp mode on and off.

@item 
@code{visual-replace-toggle-scope} changes the scope of the search.

@item 
@code{visual-replace-toggle-query} toggles the query mode on and off.

@item 
@code{visual-replace-toggle-word} toggles the word mode on and off.

@item 
@code{visual-replace-toggle-case-fold} toggles the case fold mode on and off.

@item 
@code{visual-replace-toggle-lax-ws} toggles the lax whitespace mode on and off.

@item 
@code{visual-replace-next-match} moves cursor to the next match

@item 
@code{visual-replace-prev-match} moves cursor to the previous match

@item 
@code{visual-replace-apply-one} applies a single replacement, to the
match at or after the cursor, then moves on to the next match. With a
prefix argument N, apply N replacements instead of just one.

This command, used together with @code{visual-replace-next-match}
and @code{visual-replace-prev-match} is in many cases functionally
equivalent to using the query mode, but with a different interface
that the possibility of changing the query as you go.

@item 
@code{visual-replace-apply-one-repeat} executes
@code{visual-replace-apply-one}, then install a transient map that
allows:

@quotation


@itemize *

@item 
repeating @code{visual-replace-apply-one} by typing the last part
of the key sequence used to call @code{visual-replace-apply-one-repeat}

@item 
skipping matches with @code{<down>}, which calls @code{visual-replace-next-match}

@item 
going up the match previews with @code{<up>}, which calls @code{visual-replace-prev-match}

@item 
undoing the last replacement with @code{u}
@end itemize
@end quotation

Typing anything else deactivates the transient map.

This can be configured by modifying the map @code{visual-replace-transient-map}.

This command is available on Emacs 29.1 or later.

@item 
@code{visual-replace-undo} reverts the last call to
@code{visual-replace-apply-one}. This just executes @code{undo} in
the original buffer. With a prefix argument N, call undo N times
instead of just one.
@end itemize

@node Keymaps,Hooks,Commands,Usage
@anchor{usage keymaps}@anchor{12}
@subsection Keymaps


@geindex variable; visual-replace-mode-map
@geindex variable; visual-replace-secondary-mode-map

@code{visual-replace-mode-map} is the map that is active in the
minibuffer in Visual Replace mode. You can add your own keybindings to
it.

@code{visual-replace-secondary-mode-map} is the map that defines
keyboard shortcuts for modifying the search mode, such as @code{r} to
toggle regexp mode on or off. It is bound by default in
@code{visual-replace-mode-map} to the shortcut that was used to
launch Visual Replace, but you can bind it to whatever you want, or
define custom shortcuts directly in @code{visual-replace-mode-map}.

In the example below, @code{C-l} is bound to secondary mode map and
@code{C-r} toggles the regexp mode, so it is possible to toggle the
regexp mode using either @code{C-l r} or @code{C-r}.

@example
(use-package visual-replace
  :defer t
  :bind (("C-c l" . visual-replace)
         :map visual-replace-mode-map
         ("C-r" . visual-replace-toggle-regexp))
  :config
  (define-key visual-replace-mode-map (kbd "C-l")
      visual-replace-secondary-mode-map))
@end example

@node Hooks,Limitations,Keymaps,Usage
@anchor{usage hooks}@anchor{13}
@subsection Hooks


@geindex hook; visual-replace-minibuffer-mode-hook
@geindex hook; visual-replace-functions
@geindex variable; visual-replace-defaults-hook

@code{visual-replace-minibuffer-mode-hook} is a normal hook that is
run when entering the visual replace mode, so you can set things up
just before Visual Replace starts.

@code{visual-replace-defaults-hook} is a normal hook that is run when
entering the visual replace mode with no initial match or replacement,
so you can provide some default mode without interfering with
@code{visual-replace-from-isearch} or
@code{visual-replace-thing-at-point}.

Functions in @code{visual-replace-functions} are called just before
executing the replacement or just before building the previews. They
are passed a struct of type @code{visual-replace-args}, which they
can modify. You can use it to customize the behavior of the search or
modify the regexp language.

@node Limitations,,Hooks,Usage
@anchor{usage limitations}@anchor{14}
@subsection Limitations



@itemize *

@item 
Visual Replace avoids executing replacement in the whole buffer
during preview; it just executes them in the parts of the buffer
that are currently visible. This means that the preview can show
incorrect replacement in some cases, such as when replacement uses
@cite{\#} directly or within a @cite{\@comma{}} In such cases, the preview can be
wrong but execution will be correct.

Replacements that call stateful functions in @cite{\@comma{}} such as a
function that increment an internal counter, will be executed too
many times during preview, with unpredictable results.

In all other cases, the preview should match what is eventually
executed. If that’s not the case, please @ref{15,,report an issue}.

@item 
If you use @code{visual-replace-apply-one} to replace single
matches, @code{\#} in the replacement is always 1, because single
matches are applied separately.
@end itemize

@node Contributing,,Usage,Contents
@anchor{contrib doc}@anchor{16}@anchor{contrib contributing}@anchor{17}
@section Contributing


@menu
* Reporting issues:: 
* Suggesting features:: 
* Asking questions:: 
* Code contributions:: 
* Documentation contributions:: 

@end menu

@node Reporting issues,Suggesting features,,Contributing
@anchor{contrib reporting}@anchor{15}@anchor{contrib reporting-issues}@anchor{18}
@subsection Reporting issues


At this time, the most useful thing you can do to help is and useful
bug reports to the Issue Tracker@footnote{https://github.com/szermatt/visual-replace/issues}

In your report, please discuss what you wanted to happen as well as
what happened. Also, please include enough information to reproduce
the issue.

Please include:


@itemize -

@item 
the version of Emacs you’re running, taken, for example, from @code{M-x about-emacs}

@item 
whether you’re running Emacs in a window environment or a terminal

@item 
the OS you’re running

@item 
the replacement mode - a copy of what’s shown in the minibuffer.

@item 
the text you wanted to replace, the replacement text, the
replacement modes - copying the content of minibuffer will do the
trick.
@end itemize

@cartouche
@quotation Tip 
It’s a great idea to take a screenshot of the Emacs window in Visual
Replace mode just before executing it, and then another one after
executing it and attach that to the issue.
@end quotation
@end cartouche

@node Suggesting features,Asking questions,Reporting issues,Contributing
@anchor{contrib issue-tracker}@anchor{19}@anchor{contrib suggesting-features}@anchor{1a}
@subsection Suggesting features


Please add feature suggestions to the Issue Tracker@footnote{https://github.com/szermatt/visual-replace/issues}.

@node Asking questions,Code contributions,Suggesting features,Contributing
@anchor{contrib asking-questions}@anchor{1b}
@subsection Asking questions


Open an issue on the Issue Tracker@footnote{https://github.com/szermatt/visual-replace/issues} with your question.

@node Code contributions,Documentation contributions,Asking questions,Contributing
@anchor{contrib code-contributions}@anchor{1c}
@subsection Code contributions


To contribute code to the project, open a Pull Request@footnote{https://github.com/szermatt/emacs-bash-completion/pulls}.

Before you do that, please make sure the any new features is covered
by tests and that the tests pass.

To run the tests, install and setup eldev@footnote{https://github.com/emacs-eldev/eldev} then run @code{eldev
test}.

Tests can also be run from inside of Emacs, using @cite{M-x ert-run-tests-interactively} but when you do so, be aware that there
might be unexpected interaction with your Emacs configurations. The
tests passing reliably when run using @code{eldev test} is what
matters.

Please also make sure your commit message follows Conventional Commits 1.0.0@footnote{https://www.conventionalcommits.org/en/v1.0.0/}.

@node Documentation contributions,,Code contributions,Contributing
@anchor{contrib documentation-contributions}@anchor{1d}@anchor{contrib eldev}@anchor{1e}
@subsection Documentation contributions


You don’t need to be a developer to contribute! Contribution to the
documentation or code comments are very welcome. Please open a Pull Request@footnote{https://github.com/szermatt/emacs-bash-completion/pulls} with your proposed modifications.

The documentation is written in reStructuredText. You’ll need to
install Sphinx@footnote{https://www.sphinx-doc.org} to build it:

@example
python3 -m venv venv
. venv/bin/activate # or activate.fish on fish
pip3 install -r docs/requirements.txt
@end example

Then run @code{eldev html} to build the documentation.

@node Index,,Contents,Top
@unnumbered Index


@printindex ge


@c %**end of body
@bye
